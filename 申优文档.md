# 申优文档 郭衍培 19373442

我使用 c++ 实现编译器。

## 语法分析

与所有人一样，我的语法分析采用的也是递归下降的思路。

但我的递归下降，借鉴了 rust 的 rowan 包的实现思路，架构解耦，实现简单。只用了不到四百行就实现了完整的递归下降建语法树。

首先，语法树的节点都继承一个公共的基类 Node。不同类型的符号，是 Node 的不同子类。 

构建语法树的过程,我维护两个栈，ancestor 和 children。对于非终结符,我在进入函数时执行一个 startNode，这时记录该 children 栈的大小并插入ancestor 栈。退出函数时,执行一个finishNode，将 children 栈弹至此前记录的大小，并将弹出的元素作为当前非终结符的子节点。最后将这个节点插入 children 栈。对于终结符,则直接生成一个节点，插入 children 栈中。 

语法分析中，对于赋值还是表达式非常难判断，很难知道一个东西是左值还是表达式(尤其是在可能缺少分号的情况下)。因此我对文法的这里进行了修改，左值可以是任意表达式，等到语义分析再找出。

对于所有分支，都要用当前词法元素“是什么”，而不能用“不是什么”来判断。对于开头情况比较多的表达式和语句，特别开了两个 set 来存可能的开头元素如果遇到应该是某符号但没有，比如应该是分号却不是。那么就插入一个 Error 节点，记录错误信息。 

表达式是左递归文法，这里需要对其进行转化。但转化后的语法会让同一级表达式从右往左计算，1-1-1 变成了 1-(1-1)=0。这时，需要能将某个节点插在前节点上方。这里的操作比较神奇。在进入二元运算一开始，就先记录 children 的 size。在进入函数时，不记录当前 children 栈的大小，而是前面说的其父节点函数记录的 children 的 size。这样，在这个节点 finishNode 时，自然而然就将比右运算早入栈的左运算划为了其子节点。 

## 符号表

我符号表的设计比较巧妙，能做到严格 $O(n\log s)$ 进行符号的管理。其中 $n$ 是符号的定义和使用次数，$O(\log s)$ 是在 map 或 set 单次操作字符串的复杂度。相比理论课上讲的散列栈式符号表，这个方法实现更简单，效率更高。

```c++
struct Symbol {
    map<string, FuncSymbol*> funcs;
    map<string, stack<LValSymbol*>*> vars;
    stack<set<string>*> symbolStack;
};
```

对于每个作用域，在进入时开一个新的 set\<string\>，用于存储当前作用域定义过的变量，并将这个 set 的地址插入到表示全局作用域的栈 symbolStack 的末尾。对于每个名字的变量，有一个专属的栈，记录这个名字的变量此前定义过的全部作用域。vars 用于记录所有变量的作用域栈。

每定义一个新变量，从全局作用域栈 stack\<set\*\> 的末尾取出当前作用域 set，如果当前 set 中存在这个名字，就是重复定义，否则就将这个名字插入这个 set 和 vars[变量名] 这个 stack 的末尾。在这个作用域退出时，从 stack\<set\*\> 中取出栈顶，将这个 set 里的每个字符串对应的栈的末尾弹出，最后将这个 set 中代码块 stack 弹出。

每次使用一个变量，只需查找 vars[变量名] 这个 stack 的末尾。这个末尾表示的，就是命名过这个变量的当前作用域的祖先作用域里，距离当前作用域最近的一个。正好是应该使用的变量。

## 代码生成

代码生成阶段，我将 while 循环转换为了 if do while 的格式，能减少一个无条件跳转。

## 代码优化

### SSA 建立

[SSA 参考论文](https://www.cs.utexas.edu/~pingali/CS380C/2010/papers/ssaCytron.pdf)

这个方法需要首先有普通的四元式 ir。在普通 ir 表示的控制流图的基础上，经过插入 phi 节点和重命名，转为 SSA 形式的 ir。

#### 支配树

首先需要计算支配树。

根据控制流图，可以枚举每个节点，删掉这个节点之后，从根节点有哪些节点不能从起点可达。所有不可达的节点，都被删掉的节点支配。这样，就求出了一个节点的被支配集合（若 a 支配 b ，则 a 属于 b 的被支配集合）。

一个节点的被支配集的节点中，被支配集最大的，就是这个节点在支配树上的直接父亲。

#### 插入 phi 节点

一个基本块的开始需要插入一个变量的 phi 节点的条件，是这个基本块是这个变量某个定义的支配边界。这个操作需要迭代，事实上就只需要建立一个队列，每次取出队首，计算其支配边界，并把新算出的支配边界插入到队列的末尾。

在中间代码中，可能会出现从起点到一个使用的路径中，没有任何定义的情况，对应的就是代码中可能出现未初始化的情况。因此，我默认所有变量都在起点处进行了一次定义。

#### 重命名

注意，这时的 phi 节点还是空的，即只有左值没有右值。

重命名，需要将 ir 中原本同名的变量换成不同的名字。具体方法非常简单。开一个 map<string, int>，记录每个变量当前的序号。先序遍历支配树，对每个定义，将其替换为新的序号，每个使用，替换为当前序号。在重命名完一个节点后，遍历其在控制流图中的后续节点，向它们的 phi 节点中插入这个当前的使用。

注意在遍历完一个基本块后，需要回退 map 中的序号结果。因为在另一个分支中，该变量应该使用的是更老的定义。

### 全局值编号

[GVN 参考论文](https://www.researchgate.net/publication/220752089_Global_Code_Motion_Global_Value_Numbering?enrichId=rgreq-680690d4ec513f47eac28e77f77e2be1-XXX&enrichSource=Y292ZXJQYWdlOzIyMDc1MjA4OTtBUzo1MTc2OTY3MjkzNTQyNDBAMTUwMDQzOTkyNjYzNw%3D%3D&el=1_x_2&_esc=publicationCoverPdf)

全局值编号是在 SSA IR 上，一个十分好写且有效的优化，大约相当于常量传播 + 复写传播 + 全局公共子表达式删除。SSA IR 最基本的性质是每个变量只在一个地方被定义，且除了 phi 节点的使用，其他一个变量的所有使用，一定被这个唯一的定义所支配。

因此，我们只需要先序遍历支配树，就能保证所有使用都在定义之后遍历到。对于每个赋值操作，可以直接将此后的所有这个左值替换为右值。如果右值是常数，这个替换就是常量传播，如果是变量就是复写传播。

有些运算，虽然不是直接赋值，但效果与变量赋值或常数赋值等价。比如变量加零相当于赋值，变量乘零相当于常数 0，两个相同的变量相除相当于常数 1。这里可以解决这个问题。

对于右值全都为变量且不是赋值操作的情况，可能出现进行过多次相同运算的情况。在非 SSA IR 的情况下，两个变量名字相同，他们的值可能不同。但在 SSA IR 下，这种情况就不会发生。因此，全局公共子表达式，可以只进行一次运算。对每个运算，先在哈希表中查是否之前存在过这次运算。如果存在，就将这次运算的结果替换为上次计算的值即可。如果这次运算的结果不在哈希表中，就将运算操作数和结果插进哈希表中。

对于有交换律的运算，如加法、乘法、相等，查哈希表和插入哈希表的时候，都要做第一个操作数字符串小于第二个操作数。

全局公共字表达式删除，可能遇到这样一个情况。在分支 1 计算了 c = a + b，分支 2 计算了 d = a + b。但是分支 1 和分支 2 并不相互支配（虽然 a 和 b 的定义都支配这两句话）。这样，如果把 d 复写为 c，可能会出现 c 没有定义的情况。因此，这种公共子表达式是不能合并的。在遍历完支配树上的一个节点后，需要把这个节点向哈希表中插入的所有运算删去。

### 死代码删除

我的死代码删除比较简单。如果一个变量有定义无使用，那么定义这个变量的语句就是死代码，可以删掉了。

### 寄存器分配

[寄存器分配论文](https://www.researchgate.net/publication/36450515_Towards_register_allocation_of_SSA-form_programs)

寄存器分配大抵是使用图着色法。然而，论文指出了一种隐式的图着色法。即不需要真的把图建出来，就能使用图着色。具体来说，首先要执行活跃变量分析，计算基本块的 in out。如果一个变量是当前基本块的最后一次使用，且没有 out，则它的寄存器就可以释放了。

开两个 map，记录每个变量分配的寄存器编号，和每个寄存器当前分配的变量。先序遍历支配树，进行具体的分配。在分配完当前基本块后，如果下一个基本块的 in 没有这个变量，当前寄存器就可以先释放，在处理完下一个基本块后再恢复即可。处理完全部子节点后，再释放当前基本块定义的变量所占用的寄存器。如果当前还有剩余的寄存器，就分配剩余的寄存器中号最小的那个，如果没有剩余的寄存器了，就随机 spill 一个变量即可。

### 强度削减

强度削减，主要就是除法和取模优化。

[除法优化论文](https://gmplib.org/~tege/divcnst-pldi94.pdf)

采用了论文中有符号除，向零取整的优化方式。

## 代码生成

代码生成的主要难点在于 phi 节点。phi 节点的需要将赋值语句分拆给基本块的前驱。如果前驱有唯一的后继，那么只要插到后继的末尾即可。如果有多个后继，则还需要再新建一个基本块，完成这部分赋值。

由于 phi 语句的赋值要求是同时进行，比如连续两条，第一条要求把 2 号寄存器赋值给 1 号寄存器，第二条要求把 1 号寄存器赋值给 2 号寄存器，这事实上需要达成交换 1 号和 2 号寄存的效果。然而，仅用两条语句是不可能实现的，必须使用一个临时寄存器来实现。

具体分析，如果两条赋值语句，第一条的左值等于第二条的右值，则从二号点向一号点指一条边，表示第二句必须在第一句前面执行。对于入度为 0 的点，可以直接执行。如果所有点入度都不为 0，由于左值保证唯一性，每个点的出度至多为 1，总度数至多等于点数。所以这时每个点入度出度均等于 1，整个图由多个简单环构成。对每个简单环，只需要使用一个临时寄存器进行传递，就能完成赋值。
