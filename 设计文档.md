# 编译技术设计文档——郭衍培 19373442

我使用 C++ 来写编译器。

作为一名 C with class and STL 的拥趸，写编译器这么一个运行完立即消亡的程序，当然是不会用智能指针、引用这些影响美观的东西。野指针才符合美学。当然，作为一个有基本素养的程序员，即便使用了野指针，也还是要尽可能追求内存不泄露的。

## 词法分析

一行一行地读入，然后拼起来存在一个长的 string 里。读入后，存一下前 $i$ 行的总长，以便后面根据字符地址计算行号。

使用迭代器，提供查看当前或往后几个字符的接口。由于 string 在 c++ 中本质是连续的一段内存上的字符，所以可以通过当前字符的指针，计算前后的字符，或根据首地址，计算当前字符距离开始的字符数量。

当一个词法成分时，首先读到第一个不为空格的成分，然后继续往下读。如果这个不为空格的字符是 EOF，就证明词法分析结束。

除了 ident 和关键字，绝大部分的词法元素都能通过读一个字符，或额外向前看一个字符确定。对于可能是 ident 或 keyword 的情况，我先统一视作 ident。然后建一个 set 存所有的 keyword。用 keyword 和 ident 进行匹配，如果能匹配就是 keyword，否则是 ident。

## 语法分析

语法分析主要是递归下降分析词法成分，构建语法树的过程。

首先，语法树的节点都继承一个公共的基类 Node。不同类型的符号，是 Node 的不同子类。

构建语法树的过程，我维护两个栈，ancestor 和 children。对于非终结符，我在进入函数时执行一个 startNode，这时记录该 children 栈的大小并插入 ancestor 栈。退出函数时，执行一个finishNode，将 children 栈弹至此前记录的大小，并将弹出的元素作为当前非终结符的子节点。最后将这个节点插入 children 栈。对于终结符，则直接生成一个节点，插入 children 栈中。

语法分析中，对于赋值还是表达式非常难判断，很难知道一个东西是左值还是表达式（尤其是在可能缺少分号的情况下）。因此我对文法的这里进行了修改，左值可以是任意表达式，等到语义分析再找出。

对于所有分支，都要用当前词法元素“是什么”，而不能用“不是什么”来判断。对于开头情况比较多的表达式和语句，特别开了两个 set 来存可能的开头元素。如果遇到应该是某符号但没有，比如应该是分号却不是。那么就插入一个 Error 节点，记录错误信息。

表达式是左递归文法，这里需要对其进行转化。但转化后的语法会让同一级表达式从右往左计算，1-1-1变成了 1-(1-1)=0。这时，需要能将某个节点插在当前节点上方。这里的操作比较神奇。在进入二元运算一开始，就先记录 children 的 size。在进入函数时，不记录当前 children 栈的大小，而是前面说的，其父节点函数记录的 children 的 size。这样，在这个节点 finishNode 时，自然而然就将比右运算早入栈的左运算划为了其子节点。

以上方法参考了 rust 中的 Rowan 包，思路十分巧妙，架构解耦，代码简单。

## 错误处理

错误处理的一大难点是符号表。

我符号表的设计比较巧妙，能做到严格 $O(n\log s)$ 进行符号的管理。其中 $n$是符号的定义和使用次数，$O(\log s)$ 是在 map 或 set 单次操作字符串的复杂度。

对于每个代码块，在进入时开一个新的 set\<string\>，用于存储当前作用域定义过的变量，并将这个 set 的地址插入到表示全局作用域的栈 stack\<set\<string\>\*\> 的末尾。对于每个名字的变量，有一个专属的栈，记录这个名字的变量此前定义过的全部作用域。建一个 map\<string, stack\<Variable\*\>\*\>，记录所有变量的作用域栈。

每定义一个新变量，从全局作用域栈 stack\<set\*\> 的末尾取出当前作用域 set，如果当前 set 中存在这个名字，就是重复定义，否则就将这个名字插入这个 set 和 map[变量名] 这个 stack 的末尾。在这个代码块退出时，从 stack\<set\*\> 中取出栈顶，将这个 set 里的每个字符串对应的栈的末尾弹出，最后将这个 set 中代码块 stack 弹出。

每次使用一个变量，只需查找 map[变量名] 这个 stack 的末尾。这个末尾表示的，就是命名过这个变量的当前作用域的祖先作用域里，距离当前作用域最近的一个。正好是应该使用的变量。

除了符号表，在遍历语法树找错误时，需要传不同的信息。比如为了判 break 和 continue 有没有在循环里，需要循环的层数；判表达式是左值还是表达式（语法分析时留下的坑），我们需要知道是否是赋值语句的左值。同样的，函数的返回值可能包含了是否是 return，是否是 const ，函数的参数个数及每个参数的类型等。这样不同的信息，在错误处理时需要的参数不同，给多态造成了巨大困扰。

我构建了一个 ctx 结构体，一个 ret 结构体，里面包含所有可能需要的信息和返回值。所有错误处理函数，都传一个 ctx 类型的指针，返回一个 ret 类型的指针。这样就保证了函数的参数和返回值的一致性，就可以使用多态了。

## 语义分析

与错误处理相同，在遍历语法树生成中间代码的时候，需要记录中间一些信息，像参数个数，初始化结果等。因此，我建立了 context 类型和 return 类型，用于遍历语法树时进行参数的传递。

```c++
struct BuildIRCtx {
    bool isConst, afterFuncDef, isLVal, isGlobal, needJumpElse, stmtAfterLoop;
    string *res;
    ExprNode *condition;
    BasicBlock *continueBlock, *breakBlock, *elseBlock;
};
```

context 中值得注意的是三个 BasicBlock 类型的指针。

一个循环，大抵上可以看做三个基本块：条件基本块，循环体基本块，出口基本块。如果遇到 continue 语句，就跳转到条件基本块；如果遇到 break，就跳转到出口基本块。continueBlock 和 breakBlock，都是在遍历到语法树上 While 语句的时候产生的，然后继续往下传，在遇到 continue 和 break 语句的时候才知道具体跳转到哪里。

一个有 else 的分支，大抵能看成四个基本块，条件基本块，if 基本块，else 基本块，结束基本块。在 if 基本块结束后，如果 needJumpElse 为 true，就需要跳转到结束基本块，也就是 elseBlock。elseBlock 也是在遍历到语法树上 If 语句的时候产生的。

```c++
struct BuildIRRet {
    string *res;
    string *param;
    vector<string*> args;
    vector<string*> init;
    bool isArray;
};
```

return 中少于 context，但含义有过之而无不及。首先是 res 表示表达式树上一个节点的结果。如果表达式是常数，需要在编译阶段计算出，用于确定数组下标，知道栈的大小。init 记录了数组初始化时的一列变量或常量。args 记录了调用函数时的实参名称和函数定义时的形参名称。param 表示定义函数时的单个形参。

函数定义时形参的具体信息，如数组维数、下标等存储在符号表中，本质就是一个 32 位整数（或指针）。

经过语义分析，就得到了中间代码。中间代码的设计在代码生成会有介绍。在生成中间代码的时候，对变量和函数均进行了重命名。由于此前可能有许多存在于不同作用域的同名变量，在中间语言里需要给他们进行区分。对于非临时变量，我重命名为 var_ + 原名 + _ + 编号，对于临时变量，使用 tmp_ + 编号，函数重命名为 func_ + 原函数名。这样通过不同的前缀和编号来确保没有任何的重名。

每个函数，单独建控制流图。控制流图由基本块组成，基本块由链表的结构维护，链表头即为函数入口。基本块由若干连续的语句组成，语句用链表维护。为了验证中间代码的正确性，我用 java 写了一个中间代码解释器，方便在本地对辅助用例进行测试。

## 代码生成（附中间代码介绍）

中间代码采用了自己的设计，包含以下种类。每种 ir 对应的 mips 汇编都是十分确定的。

### 赋值语句 (assign)

将一个变量赋值为另一变量或常数。对应 mips 中的 move 和 li。

### 创建指针 (create pointer)

用于定义数组，创建一个大小为 size 的数组，并将数组首地址赋给一个变量。该变量可以通过 sp 加一个固定的偏移量得到，代码生成时不需要翻译这句话。

### 除法 (divide)

计算两个变量或变量和数相除的结果并赋给一个变量。使用 div 和 mflo 指令。

### 相等 (equal)

两个变量或变量和数进行相等比较，并将结果赋给一个变量。使用 seq 指令即可。

### 函数调用 (functino call)

调用名为 name 的函数。jal 那个标签即可。

### 取整数 (get int)

将此前从外设中读到的整数赋值给一个变量。mips 中为 v0 赋值给该变量。

### 取返回值 (get return)

取出函数的返回值，赋给一个变量。mips 中为 v0 赋值给该变量。

### 大于等于 (greater or equal)

计算两个变量或变量和数进行大于等于比较的结果并赋给一个变量。使用 sge 指令。

### 大于 (greater than)

计算两个变量或变量和数进行大于比较的结果并赋给一个变量。使用 sgt 指令。

### 跳转 (jump)

无条件跳转到标签为 tag 的基本块。jump 即可。

### 条件为假时跳转 (jump when false)

条件变量等于 0 时进行跳转。使用 beqz 指令。

### 条件为真时跳转 (jump when true)

条件变量等于 1 时进行跳转。使用 bnez 指令。

### 小于等于 (less or equal)

计算两个变量或变量和数进行小于等于比较的结果并赋给一个变量。使用 sle 指令。

### 小于 (less than)

计算两个变量或变量和数进行小于比较的结果并赋给一个变量。使用 slt 指令。

### 取参数 (load parameter)

取出函数的第 num 个参数，并赋给变量。当 num < 4 时，取 $\text{a}_{\text{num}}$ 寄存器。否则，从本函数栈顶 - (num - 3) * 4 的位置取值。

### 取指针 (load pointer)

计算给的指针变量偏移一个整数变量长度后的地址，并将结果赋给变量。基地址 + 偏移量 * 4 即可。

### 内存中取字 (load word)

从给定的指针变量的整数偏移后的内存中取出一个整数，并将结果赋给变量。使用 lw 指令，需要先将偏移乘四。

### 减法 (minus)

计算两个变量或变量和数相减的结果并赋给一个变量。使用 subu 指令。

### 取模 (mod)

计算两个变量或变量和数取模的结果并赋给一个变量。使用 div 指令。

### 乘法 (multiply)

计算两个变量或变量和数相乘的结果并赋给一个变量。使用 mul 指令。

### 取反 (negate)

计算一个变量或数的相反数并将结果赋值给一个变量。使用 0 减这个变量。

### 不相等 (not equal)

两个变量或变量和数进行不相等比较，并将结果赋给一个变量。使用 sne 指令。

### 逻辑非 (not logic)

计算一个变量或数逻辑非的结果，并赋值给一个变量。等价于该变量与 0 是否相等，使用 seq 指令。

### 加法 (plus)

计算两个变量或变量和数相加的结果并赋给一个变量。使用 addu 指令。

### 输出整数 (print integer)

输出一个变量或数。使用 mips 系统调用。

### 输出字符串 (print string)

输出一个字符串。使用 mips 系统调用。

### 推参数 (push parameter)

将一个变量或数作为函数的第 num 个参数的位置。如果 num < 4，将变量或值赋值给 $\text{a}_{\text{num}}$ 寄存器。否则存入sp - (num - 3) * 4。

### 读整数 (read int)

从外设中读整数（不给变量，而是读进来）。使用 mips 系统调用，将值读到 v0 寄存器。

### 函数返回 (return)

返回一个数或变量作为返回值，也可以无返回的变量。有返回值，就将返回值存入 v0，然后从内存里恢复该函数使用了的全局寄存器。最后恢复sp 并 jr $31。

在进行汇编代码生成之前，要给没有分配寄存器的变量分配内存。除了由 create pointer 定义的变量外，其余变量每个需要大小为 4 个字节的内存。为便于解释，我在给变量定好寄存器或内存后，就将变量的名字命名为了 $register 或 sp_offset。

此外，还要保存这个函数用到的全局寄存器。代码生成时，每个函数的一开始，sp 要减去这个函数所用的栈空间。在进行一个函数的代码生成时，要按照基本块顺序进行翻译。